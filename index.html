<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>System Recovery Protocol</title>
  <style>
    * { margin:0; padding:0; box-sizing:border-box; font-family:'Courier New', monospace; }
    html,body { height:100%; }
    body {
      background:#000;
      color:#ff0000;
      overflow:hidden;
      height:100vh;
    }

    .screen {
      position:absolute;
      inset:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      transition:opacity .45s ease, visibility .45s;
      visibility:visible;
    }
    .hidden { opacity:0; pointer-events:none; visibility:hidden; }

    /* Video */
    #introVideo {
      position:fixed;
      top:0; left:0;
      width:100%;
      height:100%;
      object-fit:cover;
      z-index:5;
      background:#000;
    }

    /* An overlay shown when autoplay with sound is blocked */
    #playWithSoundOverlay {
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:15;
      pointer-events:auto;
      background: rgba(0,0,0,0.45);
    }
    .play-btn {
      border:2px solid #ff0000;
      color:#ff0000;
      background:transparent;
      padding:14px 22px;
      font-size:1.25rem;
      cursor:pointer;
      box-shadow:0 0 18px rgba(255,0,0,0.12);
    }
    .play-btn:hover { background:#ff0000; color:#000; }

    .terminal {
      background:#000;
      border:1px solid #ff0000;
      padding:20px;
      width:80%;
      max-width:820px;
      box-shadow:0 0 20px rgba(255,0,0,0.5);
      z-index:20;
    }
    .terminal-header { border-bottom:1px solid #ff0000; padding-bottom:10px; margin-bottom:18px; display:flex; justify-content:space-between; }
    .timer { font-size:3rem; margin:18px 0; text-shadow:0 0 10px #ff0000; }
    .code-input,.answer-input {
      background:transparent; border:1px solid #ff0000; color:#ff0000; padding:10px; font-size:1.2rem;
    }
    .code-input { width:200px; text-align:center; }
    .btn {
      background:transparent; border:1px solid #ff0000; color:#ff0000; padding:10px 18px; cursor:pointer; margin:10px; transition:all .2s;
    }
    .btn:hover { background:#ff0000; color:#000; box-shadow:0 0 15px #ff0000; }
    .matrix { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:1; opacity:0.25; }
    .success { color:#00ff00; text-shadow:0 0 10px #00ff00; }
    .error { color:#ff0000; text-shadow:0 0 10px #ff0000; }
    .completion-time { font-size:1.1rem; margin-top:12px; color:#00ff00; }

    .skip-btn {
      position:fixed; bottom:18px; right:18px; z-index:25; background:rgba(0,0,0,0.6);
      border:1px solid #ff0000; color:#ff0000; padding:8px 14px; cursor:pointer;
    }

    /* small screens */
    @media (max-width:520px){
      .terminal { width:92%; padding:14px; }
      .timer { font-size:2rem; }
      .play-btn { font-size:1rem; padding:10px 14px; }
    }
  </style>
</head>
<body>
  <!-- Intro Video Screen -->
  <div id="introScreen" class="screen">
    <video id="introVideo"
           playsinline webkit-playsinline
           preload="auto"
           poster=""
           tabindex="-1">
      <!-- Make sure your file is named Video.mp4 and located beside this HTML -->
      <source src="Video.mp4.mp4" type="video/mp4"/>
      Your browser doesn't support video.
    </video>

    <!-- Overlay shown when autoplay-with-sound blocked or when we want user to enable sound -->
    <div id="playWithSoundOverlay" style="display:none;">
      <div style="text-align:center;">
        <p style="color:#ff0000; margin-bottom:10px;">Click to play the intro with sound</p>
        <button class="play-btn" id="playWithSoundBtn">PLAY WITH SOUND</button>
      </div>
    </div>

    <button class="skip-btn" id="skipVideo">SKIP</button>
  </div>

  <!-- Timer Screen -->
  <div id="timerScreen" class="screen hidden">
    <div class="matrix" id="matrix"></div>
    <div class="terminal">
      <div class="terminal-header">
        <h1>SYSTEM RECOVERY PROTOCOL</h1>
        <span>ACCESS: RESTRICTED</span>
      </div>
      <p>WARNING: System compromised by unauthorized access.</p>
      <p>Initiate recovery sequence to regain control.</p>
      <p>Time until system lockout:</p>
      <div class="timer" id="timer">10:00</div>
      <p>Enter recovery code:</p>
      <input type="text" class="code-input" id="codeInput" maxlength="4" placeholder="Enter Code">
      <div>
        <button class="btn" id="submitCode">SUBMIT CODE</button>
      </div>
    </div>
  </div>

  <!-- Question Screen -->
  <div id="questionScreen" class="screen hidden">
    <div class="matrix" id="matrix2"></div>
    <div class="terminal">
      <div class="terminal-header">
        <h1>SECURITY CHALLENGE</h1>
        <span id="timeLeft">TIME: 30s</span>
      </div>
      <p>Complete the algorithm challenge to verify your identity.</p>
      <div style="margin:18px 0; padding:14px; border:1px dashed #ff0000;">
        <div id="questionText" class="question" style="font-size:1.1rem;"></div>
        <input id="answerInput" class="answer-input" placeholder="Enter your answer..." />
      </div>
      <div>
        <button class="btn" id="submitAnswer">SUBMIT ANSWER</button>
      </div>
    </div>
  </div>

  <!-- Result Screen -->
  <div id="resultScreen" class="screen hidden">
    <div class="matrix" id="matrix3"></div>
    <div class="terminal">
      <div class="terminal-header">
        <h1>SYSTEM STATUS</h1>
        <span>FINAL ANALYSIS</span>
      </div>
      <div id="resultMessage"></div>
      <div class="completion-time" id="completionTime"></div>
      <div style="margin-top:16px;">
        <button class="btn" id="restartBtn">RESTART PROTOCOL</button>
      </div>
    </div>
  </div>

  <script>
    /* ========== DOM & State ========== */
    const introScreen = document.getElementById('introScreen');
    const timerScreen = document.getElementById('timerScreen');
    const questionScreen = document.getElementById('questionScreen');
    const resultScreen = document.getElementById('resultScreen');
    const introVideo = document.getElementById('introVideo');
    const playOverlay = document.getElementById('playWithSoundOverlay');
    const playWithSoundBtn = document.getElementById('playWithSoundBtn');
    const skipVideoBtn = document.getElementById('skipVideo');
    const timerElement = document.getElementById('timer');
    const codeInput = document.getElementById('codeInput');
    const submitCode = document.getElementById('submitCode');
    const questionText = document.getElementById('questionText');
    const answerInput = document.getElementById('answerInput');
    const submitAnswer = document.getElementById('submitAnswer');
    const resultMessage = document.getElementById('resultMessage');
    const restartBtn = document.getElementById('restartBtn');
    const timeLeftElement = document.getElementById('timeLeft');
    const completionTimeElement = document.getElementById('completionTime');

    let timerInterval = null;
    let questionTimer = null;
    let timeLeft = 600; // 10 minutes
    let questionTimeLeft = 30;
    let startTime = null;
    let completionTime = null;
    let currentQuestion = null;
    let questionAnswered = false;
    let locked = false; // profile lock flag

    const questions = [
      { question: "What is the time complexity of binary search?", answer: "o(log n)" },
      { question: "What data structure uses LIFO (Last In First Out) principle?", answer: "stack" },
      { question: "What is the worst-case time complexity of quicksort?", answer: "o(n^2)" },
      { question: "Which algorithm is used to find the shortest path in an unweighted graph?", answer: "bfs" },
      { question: "What is the space complexity of merge sort?", answer: "o(n)" }
    ];

    /* ========== Matrix Background ========== */
    function createMatrixBackground(elementId) {
      const container = document.getElementById(elementId);
      if (!container) return;
      const canvas = document.createElement('canvas');
      container.appendChild(canvas);
      const ctx = canvas.getContext('2d');

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resize();
      window.addEventListener('resize', resize);

      const fontSize = 14;
      let columns = Math.floor(canvas.width / fontSize);
      let drops = new Array(columns).fill(1);

      function reinit() {
        columns = Math.floor(canvas.width / fontSize);
        drops = new Array(columns).fill(1);
      }
      reinit();

      setInterval(() => {
        if (Math.floor(canvas.width / fontSize) !== columns) reinit();
        ctx.fillStyle = "rgba(0,0,0,0.05)";
        ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.fillStyle = "#ff0000";
        ctx.font = fontSize + "px monospace";
        for (let i=0;i<columns;i++){
          const text = Math.random() > 0.5 ? '0' : '1';
          ctx.fillText(text, i*fontSize, drops[i]*fontSize);
          if (drops[i]*fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
          drops[i] += 1;
        }
      }, 40);
    }

    createMatrixBackground('matrix');
    createMatrixBackground('matrix2');
    createMatrixBackground('matrix3');

    /* ========== Video autoplay / fallback handling ========== */
    async function tryAutoplayWithSound() {
      try {
        introVideo.muted = false;
        await introVideo.play();
        playOverlay.style.display = 'none';
      } catch (err) {
        try {
          introVideo.muted = true;
          await introVideo.play();
          playOverlay.style.display = 'flex';
        } catch (err2) {
          playOverlay.style.display = 'flex';
        }
      }
    }

    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(() => { tryAutoplayWithSound(); }, 150);
    });

    playWithSoundBtn.addEventListener('click', async () => {
      try {
        introVideo.muted = false;
        await introVideo.play();
        playOverlay.style.display = 'none';
      } catch (e) {
        introVideo.muted = false;
        introVideo.play().catch(()=>{});
        playOverlay.style.display = 'none';
      }
    });

    introVideo.addEventListener('click', async () => {
      if (introVideo.muted) {
        introVideo.muted = false;
        try { await introVideo.play(); } catch(e) {}
        playOverlay.style.display = 'none';
      }
    });

    introVideo.addEventListener('ended', () => showTimerScreen());

    skipVideoBtn.addEventListener('click', () => {
      introVideo.pause();
      playOverlay.style.display = 'none';
      showTimerScreen();
    });

    setTimeout(() => {
      if (introVideo.paused && playOverlay.style.display !== 'flex') {
        showTimerScreen();
      }
    }, 8000);

    /* ========== Screen & Timer Logic ========== */
    function showTimerScreen() {
      introScreen.classList.add('hidden');
      timerScreen.classList.remove('hidden');
      startTime = new Date();
      startTimer();
    }

    function startTimer() {
      if (timerInterval) clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        timeLeft--;
        const m = Math.floor(timeLeft / 60);
        const s = timeLeft % 60;
        timerElement.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          showResult(false, "Time's up! System permanently locked.");
        }
      }, 1000);
    }

    /* ========== Recovery code logic (UNLIMITED tries allowed) ========== */
    submitCode.addEventListener('click', checkCode);
    codeInput.addEventListener('keypress', (e)=>{ if (e.key === 'Enter') checkCode(); });

    function checkCode() {
      if (locked) {
        // no second chance once locked
        alert('Profile locked — no further code attempts allowed.');
        return;
      }
      // unlimited attempts allowed here
      if (codeInput.value.trim() === '2777') {
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
        timerScreen.classList.add('hidden');
        questionScreen.classList.remove('hidden');
        askQuestion();
      } else {
        codeInput.value = '';
        codeInput.placeholder = 'INVALID CODE - TRY AGAIN';
        codeInput.focus();
      }
    }

    /* ========== Question logic ========== */
    function askQuestion() {
      if (locked) return;
      if (questionTimer) clearInterval(questionTimer);
      questionAnswered = false;
      questionTimeLeft = 30;
      timeLeftElement.textContent = `TIME: ${questionTimeLeft}s`;
      const idx = Math.floor(Math.random() * questions.length);
      currentQuestion = questions[idx];
      questionText.textContent = currentQuestion.question;
      answerInput.value = '';
      answerInput.disabled = false;
      submitAnswer.disabled = false;
      answerInput.focus();

      questionTimer = setInterval(() => {
        questionTimeLeft--;
        timeLeftElement.textContent = `TIME: ${questionTimeLeft}s`;
        if (questionTimeLeft <= 0) {
          clearInterval(questionTimer);
          // auto-submit if not already answered
          if (!questionAnswered) checkAnswer();
        }
      }, 1000);
    }

    submitAnswer.addEventListener('click', checkAnswer);
    answerInput.addEventListener('keypress', (e)=>{ if (e.key === 'Enter') checkAnswer(); });

    function checkAnswer() {
      if (questionAnswered || locked) return;
      questionAnswered = true;
      if (questionTimer) { clearInterval(questionTimer); questionTimer = null; }
      completionTime = new Date();

      const userAnswer = (answerInput.value || '').trim().toLowerCase();
      const correct = (currentQuestion.answer || '').toLowerCase();

      // disable answer input to prevent reattempt
      answerInput.disabled = true;
      submitAnswer.disabled = true;

      if (userAnswer === correct) {
        showResult(true, "SRM-ONE IS BACK LIVE! System recovery successful.");
      } else {
        // WRONG => lock profile, no restart, no second chance to re-enter code
        lockProfile("YOUR ACCOUNT IS STILL UNDER HACKER CONTROL. Security protocol failed. PROFILE LOCKED.");
      }
    }

    /* ========== Lock behavior ========== */
    function lockProfile(message) {
      locked = true;
      // stop any running timers
      if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
      if (questionTimer) { clearInterval(questionTimer); questionTimer = null; }

      // disable inputs & buttons permanently in-page
      try { codeInput.disabled = true; } catch(e){}
      try { submitCode.disabled = true; } catch(e){}
      try { answerInput.disabled = true; } catch(e){}
      try { submitAnswer.disabled = true; } catch(e){}

      // disable/hide restart (no restart allowed after lock)
      try { restartBtn.disabled = true; restartBtn.style.opacity = 0.5; restartBtn.style.pointerEvents = 'none'; } catch(e){}

      // show locked result (no restart)
      questionScreen.classList.add('hidden');
      resultScreen.classList.remove('hidden');

      // compute completion time
      let formatted = "00:00";
      if (startTime && completionTime) {
        const diff = completionTime - startTime;
        const mins = Math.floor(diff / 60000);
        const secs = Math.floor((diff % 60000) / 1000);
        formatted = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
      }
      completionTimeElement.textContent = `Completion Time: ${formatted}`;

      // show locked message
      resultMessage.innerHTML = `<h2 class="error">ACCESS DENIED</h2><p>${message}</p><p style="color:#ff0000; margin-top:8px;">Profile locked — contact administrator to restore access.</p>`;
    }

    /* ========== Result & Restart ========== */
    function showResult(success, message) {
      // if already locked, keep locked behavior
      if (locked) {
        lockProfile(message);
        return;
      }

      questionScreen.classList.add('hidden');
      resultScreen.classList.remove('hidden');

      // compute completion time
      let formatted = "00:00";
      if (startTime && completionTime) {
        const diff = completionTime - startTime;
        const mins = Math.floor(diff / 60000);
        const secs = Math.floor((diff % 60000) / 1000);
        formatted = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
      }
      completionTimeElement.textContent = `Completion Time: ${formatted}`;

      if (success) {
        resultMessage.innerHTML = `<h2 class="success">ACCESS GRANTED</h2><p>${message}</p>`;
        // ensure restart is available on success
        restartBtn.disabled = false;
        restartBtn.style.opacity = 1;
        restartBtn.style.pointerEvents = '';
      } else {
        // for non-locked failure flow (rare), show denied and still allow restart
        resultMessage.innerHTML = `<h2 class="error">ACCESS DENIED</h2><p>${message}</p>`;
        restartBtn.disabled = false;
        restartBtn.style.opacity = 1;
        restartBtn.style.pointerEvents = '';
      }
    }

    restartBtn.addEventListener('click', restartProtocol);

    function restartProtocol() {
      if (locked) {
        alert('Profile locked — restart not allowed.');
        return;
      }

      // reset state
      timeLeft = 600; questionTimeLeft = 30;
      timerElement.textContent = "10:00";
      codeInput.value = ''; codeInput.placeholder = ''; codeInput.disabled = false;
      submitCode.disabled = false;
      answerInput.value = ''; answerInput.disabled = false;
      submitAnswer.disabled = false;
      questionAnswered = false;
      completionTime = null;
      currentQuestion = null;

      // UI
      resultScreen.classList.add('hidden');
      introScreen.classList.remove('hidden');

      // rewind video and try autoplay again
      try { introVideo.currentTime = 0; } catch(e){}
      tryAutoplayWithSound();
    }

    // Safety: stop timers when page unloads
    window.addEventListener('beforeunload', () => {
      clearInterval(timerInterval);
      clearInterval(questionTimer);
    });
  </script>
</body>
</html>
